1.数据结构与算法分析 https://book.douban.com/subject/1139426/
2.https://visualgo.net
3.算法 https://book.douban.com/subject/19952400/


引论
 1.讨论内容
  对于大量输入 如何估计程序运行事件
  在尚未编码情况下比较程序运行时间
  改进程序速度确定程序瓶颈——找到需优化代码片段
 2.数学复习
   指数
   对数
   级数
   模运算
   证明方法: 归纳法 反证法
  3.递归
   递归不是循环
    如斐波那契数列，f(n)调用的是f(n-1)和f(n-2)，没有调用自身
   基本法则
    基准情形: 必须有某些基准情形 不用递归就能求解
    不断推进: 对于需递归的情形 递归调用总能朝着产生基准情形的方向推进
    设计法则: 假设所有递归调用都能运行（用归纳法证明）
    合成效益法则: 不要在不同递归调用中做相同的工作
     如斐波那契数列 f(5)调用了f(3) f(4)也调用了f(3)

算法分析
 1.数学基础
  描述增长率:
   T(N)=O(f(N)) 大O     <= f(N)
   T(N)=o(f(N)) 小o     <
   T(N)=Ω(f(N)) omega   >=
   T(N)=ω(f(N)) 小omega >
   T(N)=θ(f(N)) theta    =
  法则:
   加法: T1(N)+T2(N) = max( O(f1(N)),O(f2(N)) )
   乘法: T1(N)*T2(N) = O( f1(N)*f2(N) )
   若T(N)是一个k次多项式 则T(N)=θ(N^k)
   对数增长缓慢: (logN)^k=O(N)
  描述增长率常用函数:
   c  logN  (logN)^2  N  NlogN  N^2  N^3  2^N
  增长率比较
   f(N)/g(N) 当n→∞时
    0: f(N)=o(g(N))
    c: f(N)=θ(g(N))
    ∞: g(N)=o(f(N))
    摆动: 二者无关

 2.运行时间计算
  for循环: N
  嵌套for循环: N^2
  顺序结果: 加法

  最大子序列问题
   分治策略(divide-and-conquer)
   联机算法(on-line algorithm)
  对分查找(binary search)
   1.在一个预先排序好的整数数组中查找某个给定的整数的下标
   2.欧几里德算法: 求两个数的最大公因数(Greatest common divisor)
   3.幂运算

ADT(Abstract Data Type): 抽象数据类型


快速排序
  在最坏情况下 其会退化为冒泡排序
  既每次选取的元素只能将序列划分为一段 即选取的是最小或最大元素
  T(n)=T(n-1)+n => T(n)=n*(n+1)/2
  T(n)=T(n-1)+(n-1) => T(n)=n*(n-1)/2 哪个是正确的？

  在最优的情况下 即每次二分序列时都将序列平均地分为两部分
  T(n)=2*T(n/2)+n
  表示将长度为n的序列划分为两个子序列 每个子序列需要T(n/2)的时间 而划分序列需要n的时间
  T(n)=2*(2*T(n/4)+n/2)+n
  T(n)=4*T(n/4)+2n
  T(n)=4*(2*T(n/8)+n/4)+2n
  T(n)=8*T(n/8)+3n
  ...
  T(n)=2^m*T(n/2^m)+mn
  当2^m=n时，既m=logn
  T(n)=2^logn*T(1)+nlogn
  T(n)=n+nlogn


12每硬币称3次找出重量不同的1枚: 第一次分4组称


2个有序list交集
function intersect(arr1,arr2){
  var res=[];
  var i=0,j=0;
  while(i<arr1.length&&j<arr2.length){
    if(arr1[i]===arr2[j]){
      res.push(arr1[i]);
      i++;
      j++;
    }else if(arr1[i]<arr2[j]){
      i++;
    }else{
      j++;
    }
  }
  return res;
}