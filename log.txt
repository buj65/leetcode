数据结构与算法分析 https://book.douban.com/subject/1139426/
https://visualgo.net

引论
 1.讨论内容
  对于大量输入 如何估计程序运行事件
  在尚未编码情况下比较程序运行时间
  改进程序速度确定程序瓶颈——找到需优化代码片段
 2.数学复习
   指数
   对数
   级数
   模运算
   证明方法: 归纳法 反证法
  3.递归
   递归不是循环
    如斐波那契数列，f(n)调用的是f(n-1)和f(n-2)，没有调用自身
   基本法则
    基准情形: 必须有某些基准情形 不用递归就能求解
    不断推进: 对于需递归的情形 递归调用总能朝着产生基准情形的方向推进
    设计法则: 假设所有递归调用都能运行（用归纳法证明）
    合成效益法则: 不要在不同递归调用中做相同的工作
     如斐波那契数列 f(5)调用了f(3) f(4)也调用了f(3)

算法分析
 1.数学基础
  描述增长率:
   T(N)=O(f(N)) 大O     <= f(N)
   T(N)=o(f(N)) 小o     <
   T(N)=Ω(f(N)) omega   >=
   T(N)=ω(f(N)) 小omega >
   T(N)=θ(f(N)) theta    =
  法则:
   加法: T1(N)+T2(N) = max( O(f1(N)),O(f2(N)) )
   乘法: T1(N)*T2(N) = O( f1(N)*f2(N) )
   若T(N)是一个k次多项式 则T(N)=θ(N^k)
   对数增长缓慢: (logN)^k=O(N)
  描述增长率常用函数:
   c  logN  (logN)^2  N  NlogN  N^2  N^3  2^N
  增长率比较
   f(N)/g(N) 当n→∞时
    0: f(N)=o(g(N))
    c: f(N)=θ(g(N))
    ∞: g(N)=o(f(N))
    摆动: 二者无关

 2.运行时间计算
  for循环: N
  嵌套for循环: N^2
  顺序结果: 加法

  最大子序列问题
   分治策略(divide-and-conquer)
   联机算法(on-line algorithm)
  对分查找(binary search)
   1.在一个预先排序好的整数数组中查找某个给定的整数的下标
   2.欧几里德算法: 求两个数的最大公因数(Greatest common divisor)
   3.幂运算

ADT(Abstract Data Type): 抽象数据类型


快速排序
  在最坏情况下 会退化为冒泡排序
  既每次选取的元素是最小或最大元素 只能将序列划分为一段
  T(n)=T(n-1)+n => T(n)=n*(n+1)/2

  在最优的情况下 即每次都将序列平均地分为两部分
  T(n)=2*T(n/2)+n
      =2*(2*T(n/4)+n/2)+n
      =4*T(n/4)+2n
      =4*(2*T(n/8)+n/4)+2n
      =8*T(n/8)+3n
      ...
      =2^m*T(n/2^m)+mn
  最优情况下2^m=n，既m=logn，因此
  T(n)=2^logn*T(1)+nlogn
      =n+nlogn


12每硬币称3次找出重量不同的1枚: 第一次分4组称


树的前(先)序遍历, 中序遍历, 后序遍历
  先序 Pre-order: 根节点->左子树->右子树
  中序 In-order: 左子树->根节点->右子树
  后序 Post-order : 左子树->右子树->根节点
         A
       /    \
      B      C
     / \    / \
    D   E  F   G
   / \        /
  H   I      J
              \
               K
  先序: A B D H I E C F G J K
  中序: H D I B E A F C J K G
  后序: H I D E B F K J G C A